<problem>
  <choiceresponse>
    <label>Which is correct?&lt;br/&gt;</label>
    <checkboxgroup>
      <choice correct="false">抽象類別有 1..* 個抽象方法&lt;br/&gt;(abstract class has 1 to many abstract method)
</choice>
      <choice correct="true">抽象類別有 0..* 個具體方法&lt;br/&gt;(abstract class can have zero to many concrete method)
</choice>
      <choice correct="true">具體類別不可以有任何抽象方法。&lt;br/&gt;(concrete class can't have any abstract method)
</choice>
    </checkboxgroup>
  </choiceresponse>
  <multiplechoiceresponse>
    <label>我們設計了一個演算法可以找出三個參數中最棒的的一個（best(x, y, z)）。例如三個整數最棒的數就是最大的那個數。我們想要多應用這個演算法，讓他一般化、普及化到更多物件。&lt;br/&gt;以下何者正確？&lt;br/&gt;(We design an algorithm for getting the best (best(x,y,z)). For example the best of three integers are the biggest one. If we want to apply this algorithm and make it more general to other objects, which following description is correct?)&lt;br/&gt;</label>
    <choicegroup type="MultipleChoice">
      <choice correct="true">可以應用 interface 的技巧，讓整數等要比較的物件實作此 interface&lt;br/&gt;(apply the mechanism of &lt;em&gt;interface&lt;/em&gt;, let integer and other comparable object implement the interface)
</choice>
      <choice correct="false">只要把 x, y, z  的型態改為 Object 即可解決此問題&lt;br/&gt;(declare x, y, z as the type of &lt;em&gt;Object&lt;/em&gt;)
</choice>
      <choice correct="false">整數是一個原生型態的資料，不是類別因此無法處理。其他類別可以達到此功能。&lt;br/&gt;(integer is a primitive type, so we can't handle it in this case; but other class is ok)
</choice>
    </choicegroup>
  </multiplechoiceresponse>
  <multiplechoiceresponse>
    <label>Which is incorrect?&lt;br/&gt;</label>
    <choicegroup type="MultipleChoice">
      <choice correct="false">建構子的名稱和類別名稱一樣 (the name of constructor is same as the class name)
</choice>
      <choice correct="true">一個類別建構子只能有一個 (a class can have only one constructor)
</choice>
      <choice correct="false">建構子不會有回傳值 (只能用 void) (a constructor can't have a return value; only void can be used)
</choice>
    </choicegroup>
  </multiplechoiceresponse>
  <multiplechoiceresponse>
    <label>繪製循序圖時，可能需要參考其他的圖型，但以下何者不太可能需要參考：&lt;br/&gt;(When we draw the sequence diagram, we may reference some other diagrams; which diagram is seldom referred?)&lt;br/&gt;</label>
    <choicegroup type="MultipleChoice">
      <choice correct="false">使用案例圖 (use case diagram)
</choice>
      <choice correct="false">類別圖 (class diagram)
</choice>
      <choice correct="true">系統配置圖 (deployment diagram)
</choice>
      <choice correct="false">活動圖 (activity diagram)
</choice>
    </choicegroup>
  </multiplechoiceresponse>
  <choiceresponse>
    <label>X and Y are not primitive type, they are class type. Which are correct?&lt;br/&gt; &lt;br/&gt;class P {&lt;br /&gt;   private X x1;&lt;br /&gt;   public void m1(Y y1) {…}&lt;br /&gt;   public void setX(X x2) {x1 = x2;}&lt;br /&gt;   public P(X x) {x1 = x}&lt;br /&gt;}&lt;br/&gt; &lt;br/&gt;</label>
    <checkboxgroup>
      <choice correct="false">x1 是一個 P 的 static variable &lt;br/&gt;(x1 is a static variable)
</choice>
      <choice correct="true">P 是一個 mutable class &lt;br/&gt;(p is a mutable class)
</choice>
      <choice correct="false">若 y2 是 「Y的子類別」所生成的物件， m1(y2) 將導致compiler 產生錯誤 &lt;br/&gt;(if y2 is an instance of the subclass of Y, m1(y2) will cause compiler error)
</choice>
      <choice correct="true">Y 可以是一個 interface &lt;br/&gt;(Y may be an interface)
</choice>
      <choice correct="true">Y 可以是一個 abstract class &lt;br/&gt;(Y may be an abstract class)
</choice>
      <choice correct="false">P2 extends P implements L1, L2 是不可以的，因為在 java 中不可多重繼承(L1, L2 是介面) &lt;br/&gt;(if L1, L2 are interface, the statement: P2 extends P implements L1, L2 is error since multiple inheritance is not allowed in Java)
</choice>
      <choice correct="false">同上，P2 內不可以呼叫 m1 方法，因為它不是宣告為 protected &lt;br/&gt;(following the statement above, in P2 we can't call m1() since m1 is not declared as protected
</choice>
      <choice correct="true">P p = new P(); 會導致編譯錯誤，因為預設建構子已失效。&lt;br/&gt;(P p = new P() will cause compiler error since the default constructor doesn't work any more)
</choice>
    </checkboxgroup>
  </choiceresponse>
  <multiplechoiceresponse>
    <label>關於開畢原則何者為是？(about OCP principle, what is correct)&lt;br/&gt;</label>
    <choicegroup type="MultipleChoice">
      <choice correct="false">檔案開啟後且使用過後一定記得關閉該檔案。(when you open a file, you have to close it)
</choice>
      <choice correct="false">軟體開發專案開始時必須有規劃，結案時必須有統整分析。&lt;br/&gt;(you should plan for your software project, when it is closed, you should have a summary report)
</choice>
      <choice correct="true">系統設計儘量允許開放擴充，避免直接修改。&lt;br/&gt;(when you design your system, make it easy to extend, and avoid modifying it as you can)
</choice>
      <choice correct="false">一個案子必須結束後才能進行下一個案子，以求最好的效能。&lt;br/&gt;(You should open a new project only if you have closed a project)
</choice>
    </choicegroup>
  </multiplechoiceresponse>
  <multiplechoiceresponse>
    <label>Which is incorrect?&lt;br/&gt;</label>
    <choicegroup type="MultipleChoice">
      <choice correct="true">設計應該模組化，達到低內聚力，高耦合度 (when we design a software system, the system should be modularized, to achieve the low cohesion and high coupling)
</choice>
      <choice correct="false">「相依反轉」說的是，高階的物件不該相依相依於低階，應該都相依於抽象&lt;br/&gt;(Dependency Inversion Principle: high level modules should not depend on the low level modules; both of them should depend on abstraction)
</choice>
      <choice correct="false">LSP 告訴我們概念上的一般化，不一定都有繼承關係&lt;br/&gt;(Liskov Substitution Principle tells us not all generalization relationship leads to inheritance relationship)
</choice>
      <choice correct="false">不重複原則，說的是資料和程式碼應該要避免重&lt;br/&gt;(Don't repeat yourself, means we should avoid duplication both on code and data)
</choice>
    </choicegroup>
  </multiplechoiceresponse>
</problem>
